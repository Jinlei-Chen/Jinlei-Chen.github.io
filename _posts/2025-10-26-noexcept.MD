---
layout: post
title: 右值引用和移动语义
date: 2025-10-26 08:00:00 +0800
---
在 C++ 中，[noexcept] 是一个关键字，用于声明函数是否可能抛出异常。它是在 C++11 标准中引入的。
**备注：函数默认是抛出异常，所以使用 [noexcept] 关键字时，请确保函数不会抛出异常。**
### 使用 [noexcept]

1. **不带参数的 ：**
   - 表示该函数不会抛出任何异常。
   - 示例：
     ```cpp
     void func() noexcept;
     ```

2. **带参数的 [noexcept(...)]：**
   - 可以根据条件决定函数是否抛出异常。
   - [noexcept(true)]：等同于 [noexcept]，表示函数不会抛出异常。
   - [noexcept(false)]：表示函数可能会抛出异常。
     ```cpp
     void func1() noexcept(true);  // 不会抛出异常
     void func2() noexcept(false); // 可能会抛出异常
     ```

3. **作为运算符使用**：
   - [noexcept(expr)]：判断表达式 [expr] 是否不会抛出异常。
   - 如果 [expr] 不会抛出异常，则返回 `true`；否则返回 `false`。
     ```cpp
     template <typename T>
     void myFunction(T t) noexcept(noexcept(t.method())) {
         // 如果 T::method() 不抛出异常，则此函数也不抛出异常
     }
     ```

### [noexcept] 的作用

- **性能优化**：编译器可以对 [noexcept] 函数进行优化，因为知道它们不会抛出异常。
- **代码安全性**：通过明确声明哪些函数不会抛出异常，可以提高代码的可读性和可靠性。
- **资源管理**：确保某些关键操作（如析构函数、移动构造函数）不会抛出异常，从而避免资源泄漏。

### 示例代码

```cpp
#include <iostream>

void foo() noexcept {
    std::cout << "This function does not throw exceptions." << std::endl;
}

void bar() noexcept(false) {
    throw std::runtime_error("An error occurred!");
}

int main() {
    try {
        foo();           // 正常执行
        bar();           // 抛出异常
    } catch (const std::exception& e) {
        std::cerr << "Caught exception: " << e.what() << std::endl;
    }

    return 0;
}
```

在这个例子中：
- `foo()` 被标记为 `noexcept`，因此不会抛出异常。
- `bar()` 被标记为 `noexcept(false)`，所以可以抛出异常。
如果将 bar() 的参数类型改为 `noexcept(true)`，则 `bar()` 将被标记为 `noexcept`，会出现什么情况
``` 
#include <iostream>

void foo() noexcept {
    std::cout << "This function does not throw exceptions." << std::endl;
}

void bar() noexcept {
    throw std::runtime_error("An error occurred!");
}

int main() {
    try {
        foo();           // 正常执行
        bar();           // 抛出异常
    } catch (const std::exception& e) {
        std::cerr << "Caught exception: " << e.what() << std::endl;
    }

    return 0;
}
```
编译的时候会出现警告
```
throw will always call terminate() [-Wterminate]
     throw std::runtime_error("An error occurred!");
```
运行程序时，会出现错误
```
terminate called after throwing an instance of 'std::runtime_error'
  what():  An error occurred!
```
所以：如果一个 noexcept 函数抛出了异常，程序会调用 std::terminate() 终止执行。
### 四、注意事项

1. **不要随意添加 `noexcept`**
   - 如果函数内部实际可能抛出异常，却标记为 `noexcept`，会导致未定义行为（最终调用 `std::terminate()`）。

2. **移动构造函数和赋值尽量标记为 `noexcept`**
   - 这样可以让 STL 容器更高效地处理资源转移。

3. **避免在 `noexcept` 函数中调用可能抛出异常的函数**
   - 若无法避免，请确保其不会真正抛出异常。

4. **使用条件性 `noexcept` 提高泛型编程安全性**
   - 如模板函数中根据参数类型决定是否 `noexcept`。

---

### 五、典型使用场景

#### 1. 移动构造函数和赋值运算符

```cpp
class MyVector {
public:
    MyVector(MyVector&& other) noexcept;
    MyVector& operator=(MyVector&& other) noexcept;
};
```

#### 2. 析构函数默认为 `noexcept`

```cpp
~MyClass() noexcept; // 默认就是 noexcept，无需显式写出
```

> 注意：若析构函数可能抛出异常，应特别小心，通常应确保其为 `noexcept`。

#### 3. 与 `std::move_if_noexcept`

```cpp
std::vector<MyClass> vec;
vec.push_back(std::move_if_noexcept(obj)); // std::move_if_noexcept 是 C++11 引入的一个标准库工具函数，定义在 <utility> 头文件中。它的作用是在移动构造函数不会抛出异常时返回右值引用（即允许移动），否则返回左值引用（即使用拷贝）。
```

- 如果 `MyClass` 的移动构造函数是 `noexcept`，则使用移动；
- 否则使用拷贝以避免异常。

---
### 总结

- `noexcept` 是 C++11 引入的关键字，用于指定函数是否会抛出异常。
- 它可以帮助编译器进行优化，并提高代码的安全性和可维护性。
- 移动语义控制：在移动构造函数和移动赋值操作符中使用 noexcept 可以确保容器类选择更高效的实现路径。
  - 如果移动构造函数不是 noexcept，则标准库容器可能会优先选择复制而不是移动操作以确保异常安全。
- 如果你想让某个函数保证不会抛出异常，可以将其声明为 [noexcept]
  
| 项目 | 说明 |
|------|------|
| 关键字 | `noexcept` |
| 目的 | 显式声明函数不会抛出异常 |
| 优点 | 异常安全、性能优化、支持 STL 更高效的实现 |
| 使用建议 | 在移动语义、析构函数等关键位置合理使用 |
| 错误使用后果 | 抛出异常将导致程序终止 |
